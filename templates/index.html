<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Ansible Mind Map Viewer</title>
  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Roboto, 'Segoe UI', Arial; margin: 12px; }
    #mynetwork { width: 100%; height: 520px; border: 1px solid #ddd; }
    #panels { display:flex; gap: 12px; width:100%; margin-top:10px; }
    textarea { width:100%; height: 360px; font-family: monospace; }
    .col { flex:1; }

    /* Chatbot styles */
    #ai-chat-section {
      margin-top: 20px;
    }
    #chat-container {
      background: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      min-height: 80px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    #ai-response {
      white-space: pre-wrap;
      line-height: 1.4;
      color: #222;
      font-size: 0.95em;
    }
    #typing-indicator {
      display: none;
      font-style: italic;
      color: #888;
    }
  </style>
</head>
<body>
  <h2>Ansible Playbook Mind Map Viewer</h2>
  <p>Upload a JSON or text file of Ansible playbook output. Click nodes to expand/collapse details.</p>

  <form id="uploadForm">
    <input type="file" id="fileInput" name="file" accept=".json,.txt" />
    <button type="submit">Upload & Generate</button>
  </form>

  <div id="mynetwork"></div>

  <div id="panels">
    <div class="col">
      <h3>Nested JSON</h3>
      <textarea id="jsonOut" readonly></textarea>
    </div>
    <div class="col">
      <h3>Markdown List</h3>
      <textarea id="mdOut" readonly></textarea>
    </div>
    <div class="col">
      <h3>Top 20 Time-Consuming Tasks</h3>
      <textarea id="topTasksOut" readonly>Upload output to analyze.</textarea>
    </div>
    <div class="col">
      <h3>Failing Tasks</h3>
      <textarea id="FailedTasks" readonly>Upload output to analyze.</textarea>
    </div>
  </div>

  <!-- Chatbot Section -->
  <div id="ai-chat-section">
    <h3>ðŸ’¬ AI Insight</h3>
    <div id="chat-container">
      <div id="ai-response"></div>
      <div id="typing-indicator">AI is thinking<span id="dots">.</span></div>
    </div>
  </div>

  <script>
    const form = document.getElementById('uploadForm');
    const fileInput = document.getElementById('fileInput');
    const jsonOut = document.getElementById('jsonOut');
    const mdOut = document.getElementById('mdOut');
    const topTasksOut = document.getElementById('topTasksOut');

    let network = null;
    let nestedJson = null;
    let nodes = null;
    let edges = null;
    const displayedNodes = new Set();
    const expandedNodes = new Set();

    function findNodeInNested(node, id) {
      if (node.id === id) return node;
      for (const child of node.children || []) {
        const found = findNodeInNested(child, id);
        if (found) return found;
      }
      return null;
    }

    function toggleChildren(nodeId) {
      const node = findNodeInNested(nestedJson, nodeId);
      if (!node || !node.children) return;

      if (expandedNodes.has(nodeId)) {
        node.children.forEach(child => removeNodeRecursive(child.id));
        expandedNodes.delete(nodeId);
      } else {
        node.children.forEach(child => {
          if (!displayedNodes.has(child.id)) {
            nodes.add({id: child.id, label: child.label, title: child.title || ''});
            edges.add({from: nodeId, to: child.id});
            displayedNodes.add(child.id);
          }
        });
        expandedNodes.add(nodeId);
      }
    }

    function removeNodeRecursive(nodeId) {
      const node = findNodeInNested(nestedJson, nodeId);
      if (!node) return;
      if (node.children) node.children.forEach(child => removeNodeRecursive(child.id));
      if (displayedNodes.has(nodeId)) {
        nodes.remove(nodeId);
        displayedNodes.delete(nodeId);
      }
      edges.forEach(edge => {
        if (edge.from === nodeId || edge.to === nodeId) edges.remove(edge.id);
      });
      if (expandedNodes.has(nodeId)) expandedNodes.delete(nodeId);
    }

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const file = fileInput.files[0];
      if (!file) return alert('Please pick a JSON or text file first');

      const fd = new FormData();
      fd.append('file', file);

      const resp = await fetch('/top_tasks_analysis', { method: 'POST', body: fd });
      if (!resp.ok) {
        const txt = await resp.text();
        return alert('Upload failed: ' + txt);
      }

      const json = await resp.json();
      nestedJson = json.nested_json;

      jsonOut.value = JSON.stringify(nestedJson, null, 2);
      mdOut.value = json.markdown;

      // Top 20 list into textarea
      if (json.top_20_time_consuming_tasks && json.top_20_time_consuming_tasks.length > 0) {
        const lines = json.top_20_time_consuming_tasks.map(
          (t, i) => `${i + 1}. ${t.play} â†’ ${t.task} (${t.duration_seconds.toFixed(2)}s)`
        );
        topTasksOut.value = lines.join('\n');

        // Failing Tasks
        const failedOut = document.getElementById('FailedTasks');
        if (json.failed_tasks && json.failed_tasks.length > 0) {
          const lines = json.failed_tasks.map(
            (t, i) =>
              `${i + 1}. Play: ${t.play}\n` +
              `   Task: ${t.task}\n` +
              `   Host: ${t.host}\n` +
              `   Message: ${t.message}`
          );
          failedOut.value = lines.join('\n\n');
        } else {
          failedOut.value = 'No failing tasks found.';
        }
      } else {
        topTasksOut.value = 'No duration data found in this log.';
      }

      // Mind map setup
      nodes = new vis.DataSet([{id: nestedJson.id, label: nestedJson.label, title: nestedJson.title}]);
      edges = new vis.DataSet([]);
      displayedNodes.clear();
      expandedNodes.clear();
      displayedNodes.add(nestedJson.id);

      const container = document.getElementById('mynetwork');
      const data = { nodes, edges };
      const options = {
        layout: { hierarchical: false },
        nodes: { shape: 'box', margin: 8 },
        physics: { stabilization: true },
        interaction: { hover: true }
      };

      if (network) network.destroy();
      network = new vis.Network(container, data, options);
      network.on("click", function (params) {
        if (params.nodes.length > 0) toggleChildren(params.nodes[0]);
      });

      // Generate AI-style insight
      let insight = '';

      if (json.failed_tasks && json.failed_tasks.length > 0) {
        insight += `I noticed ${json.failed_tasks.length} task(s) failed. `;
        const first = json.failed_tasks[0];
        insight += `The first failure occurred in play "${first.play}" on host "${first.host}" due to "${first.message}". `;
      }

      if (json.top_20_time_consuming_tasks && json.top_20_time_consuming_tasks.length > 0) {
        const longest = json.top_20_time_consuming_tasks[0];
        insight += `Also, the task "${longest.task}" took the longest time (${longest.duration_seconds.toFixed(2)}s), which might indicate a bottleneck.`;
      }

      if (!insight)
        insight = "Everything looks good â€” no failures or long-running tasks detected.";

      showTypingEffect(insight);
    });

    // Typing animation
    function showTypingEffect(text) {
      const aiResponse = document.getElementById('ai-response');
      const typing = document.getElementById('typing-indicator');
      aiResponse.textContent = '';
      typing.style.display = 'block';

      let i = 0;
      const speed = 25; // ms per character

      function typeChar() {
        if (i < text.length) {
          aiResponse.textContent += text.charAt(i);
          i++;
          setTimeout(typeChar, speed);
        } else {
          typing.style.display = 'none';
        }
      }
      setTimeout(typeChar, 400);
    }

    // Animate dots (...)
    setInterval(() => {
      const dots = document.getElementById('dots');
      if (dots) dots.textContent = dots.textContent.length < 3 ? dots.textContent + '.' : '.';
    }, 400);
  </script>
</body>
</html>
